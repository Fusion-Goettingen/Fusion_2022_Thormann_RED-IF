import numpy as np

# scenario 0: low noise on orientation
# scenario 1: high noise on orientation
SCENARIO_ID = 1
DIRECT = False  # get direct measurements
SIMULATE_AMBIGUITY = False
NO_KIN = False  # no kinematic movement, i.e., kinematic velocity is ignored
LOAD_DATA = False

TIME_STEPS = 15  # number of time steps
TD = 1.0  # time difference between steps
GT_POIS = 5  # poisson rate of measurements generated by ground truth
RUNS = 1000

INIT_STATE = np.array([0.0, 0.0, 10.0, 0.0, 0.0, 5.0, 1.5])

# noise on point measurements
MEAS_COV1 = np.diag([2.0, 0.5])**2
MEAS_COV2 = np.diag([0.5, 2.0])**2
MEAS_COV = [MEAS_COV1, MEAS_COV2]

# measurement covariance if state is measured directly
DIRECT_MEAS_COV1 = np.diag([0.2, 0.2, 0.05, 0.05, np.sqrt(0.2*np.pi), 0.5, 0.1])**2
DIRECT_MEAS_COV2 = np.diag([0.2, 0.2, 0.05, 0.05, np.sqrt(0.2*np.pi), 0.1, 0.5])**2
DIRECT_MEAS_COV = [DIRECT_MEAS_COV1, DIRECT_MEAS_COV2]

# process noise
SIGMA_OR = np.sqrt(0.01*np.pi) if SCENARIO_ID == 0 else np.sqrt(0.2*np.pi)
SIGMA_V1 = 0.8
SIGMA_V2 = 0.8
RM_FORGET = 6.0 if SCENARIO_ID == 0 else 3.0

# for plotting
AX_LIMS = [-10, 160, -40, 40]

# for tracking
INIT_STATE_COV = np.diag([1.0, 1.0, 0.8, 0.8, np.sqrt(0.5*np.pi), 0.2, 0.1])**2
INIT_RATE = 8.0
AX_MIN = 0.1  # minimum semi-axis length

# for RED mixture reduction
WEIGHT_THRESH = 1e-6  # weight threshold for discarding components
MAX_COMP = 32  # maximum number of components; prune if necessary
CLOSE_THRESH = 0.05

# MEM-EKF*
MEM_H = np.array([
    [1.0, 0.0, 0.0, 0.0],
    [0.0, 1.0, 0.0, 0.0],
])
MEM_KIN_DYM = np.array([
    [1.0, 0.0, TD,  0.0],
    [0.0, 1.0, 0.0,  TD],
    [0.0, 0.0, 1.0, 0.0],
    [0.0, 0.0, 0.0, 1.0],
])
MEM_SHAPE_DYM = np.identity(3)

# indices for ground truth and estimate
X1 = 0
X2 = 1
V1 = 2
V2 = 3
AL = 4
L = 5
W = 6
